<?php

/**
  * @file
  * Code for the Faculty Publications feature.
  */
include_once 'cu_faculty_publications_bundle.features.inc';

/**
  * Implements hook_theme_registry_alter().
  *
  * Let Drupal know that we've got bean--faculty_publications.tpl.php in our module
  * directory.
  */
function cu_faculty_publications_bundle_theme_registry_alter(&$theme_registry) {
  $module_path = drupal_get_path('module', 'cu_faculty_publications_bundle');
  $theme_registry_copy = $theme_registry;
  _theme_process_registry($theme_registry_copy, 'phptemplate', 'theme_engine', 'bean', $module_path);
  $theme_registry += array_diff_key($theme_registry_copy, $theme_registry);
  $hooks = array('bean');
  foreach ($hooks as $h) {
    if (isset($theme_registry[$h]['theme paths'])) {
      $first_element = array_shift($theme_registry[$h]['theme paths']);
      array_unshift($theme_registry[$h]['theme paths'], array_shift($theme_registry[$h]['theme paths']), $module_path);
    }
  }
}

/**
  * Implements hook_theme().
  */
function cu_faculty_publications_bundle_theme(&$existing, $type, $theme, $path) {
  $registry = array();
  $template_dir = drupal_get_path('module', 'cu_faculty_publications_bundle') . '/templates';
  $registry['faculty_publication'] = array(
    'template' => 'faculty-publication',
    'path' => $template_dir,
  );
  return $registry;
}

/**
  * Implements hook_preprocess_entity().
  */
function cu_faculty_publications_bundle_preprocess_entity(&$vars) {
  if ($vars['elements']['#bundle'] == 'faculty_publications') {

    $endpoint = variable_get('cu_faculty_publications_endpoint', 'https://experts.colorado.edu/es/fispubs-v1/publication/_search');
    $fisEndpoint = variable_get('cu_faculty_fis_endpoint', 'https://experts.colorado.edu/es/fis/_search');
    $nodePath = drupal_get_normal_path($_GET['q']);
    global $user;
    $skipCache = in_array('developer', $user->roles) || in_array('administrator', $user->roles);

    $publicationData = get_publication_data($nodePath, false, $vars['bean']);

    if ($publicationData['results']) {
      $totalResults = $publicationData['total'] > $publicationData['requestedNumberOfResults'] ? $publicationData['requestedNumberOfResults'] : $publicationData['total'];
      pager_default_initialize($totalResults, 25);

      // Check if results are from cache.
      // Put in an HTML comment to confirm if results are from cache or not.
      $isFromCache = $publicationData['isFromCache'] ? "YES" : "NO";
      $vars['content']['publications'][]['#markup'] = "<!-- Publication data are from cache: $isFromCache -->";

      foreach ($publicationData['results'] as $item) {
        $vars['content']['publications'][]['#markup'] = theme('faculty_publication', $item['_source']);
      }

      $vars['content']['publications'][]['#markup'] = theme('pager');
    }

    else {
      $vars['content']['no_results'][]['#markup'] = '<h4>There are no results for your query. Please check your data filters and try again.</h4>';
    }
  }
}

// Here are many helper functions used in cu_faculty_publications_bundle_preprocess_entity() above.
function get_array_from_field_data($fieldArray, $fieldArrayFinalIdentifier) {
  return array_map(function($data) use($fieldArrayFinalIdentifier) { return strtolower($data[$fieldArrayFinalIdentifier]); }, $fieldArray);
}

function get_author_orcids($authorEmailArray, $dbUrl) {
  if (count($authorEmailArray) == 0) {
    return;
  }

  $orcids = array();
  $authorEmailString = formQueryStringFromArray($authorEmailArray);
  $queryArray = ['q' => "email:{$authorEmailString}"];
  $requestUrl = url($dbUrl, ['query' => $queryArray]);
  $emailResponse = drupal_http_request($requestUrl);

  if ($emailResponse->code =='200') {
    $emailResult = drupal_json_decode($emailResponse->data, true);
    $data = $emailResult['hits']['hits'];
    // get the orcids from each database hit
    foreach($data as $author) {
      $authorOrcid = $author['_source']['orcid'];
      $authorEmail = strtolower($author['_source']['email'][0]);
      if ($authorOrcid) {
        array_push($orcids, $authorOrcid);
        $index = array_search($authorEmail, $authorEmailArray);
        array_splice($authorEmailArray, $index, 1);
      }
    }
  }

  $noResults = count($orcids) > 0 ? FALSE : TRUE;
  return ['orcids' => $orcids, 'notFound' => $authorEmailArray, 'noResults' => $noResults];
}

function formQueryStringFromArray($arr) {
  $arrayQuoted = array_map(function($data) { return "\"" . $data . "\""; }, $arr);
  return '(' . implode(" OR ", $arrayQuoted) . ')';
}

function get_html_no_result_string($noResultArray, $label) {
  if (count($noResultArray) > 0 && $label) {
    $warningString = "<p style=\"margin: 0;\">No {$label} found for:</p><ul>";
    foreach ($noResultArray as $data) {
      $warningString .= "<li>$data.</li>";
    }
    $warningString .= "</ul>";
  }
  return $warningString ? $warningString : '';
}

/**
 * Undocumented function
 *
 * @param [string] $url
 * @return array of publication data
 */
function get_publication_data($url, $skipCache, $beanObject) {
  $cache = cache_get($url, 'cache_cu_faculty_publications_bundle');

  // First check if there is data in the cache and that it has not expired.
  // If so there is no need to build elastic search url, just return the cache.
  if (isset($cache->data) && $cache->data['expiration'] > time() && $skipCache === FALSE) {
    $publications = $cache->data['publications'];
    $publications['isFromCache'] = true;
    $publications['isFresh'] = true;
    return $publications;
  }
  
  // If the cache has expired try to refresh it and load new data.
  else if (isset($cache->data) && $cache->data['expiration'] <= time()) {
    $reqData = [ 'reqUrl' => $cache->data['reqUrl'], 'requestedNumberOfResults' => $cache->data['publications']['requestedNumberOfResults'] ];
    $response = drupal_json_decode(drupal_http_request($reqData['reqUrl'])->data, true);
    
    if ($response) {
      $newData = build_publication_data($response, $reqData, false, true);
      cache_set($url, $newData['cacheData'], 'cache_cu_faculty_publications_bundle');
      return $newData['publications'];
    }

    // If there is no response simply load cache even though it is expired.
    else {
      return build_publication_data($cache->data, '', true, false)['publications'];
    }
  }
  // If there is no cached data.
  else {
    $requestData = build_request_data($beanObject);
    $response = drupal_json_decode(drupal_http_request($requestData['reqUrl'])->data, true);
    
    if ($response) {
      $newData = build_publication_data($response, $requestData, false, true);
      cache_set($url, $newData['cacheData'], 'cache_cu_faculty_publications_bundle');
      return $newData['publications'];
    }
  }
}

function build_publication_data($pubData, $reqData, $isFromCache, $isFresh) {
  // Build data to save to the cache.
  $cacheData = [
    'publications' => [
      'total' => $pubData['hits']['total'],
      'results' => $pubData['hits']['hits'],
      'requestedNumberOfResults' => $reqData['requestedNumberOfResults']
    ],
    'expiration' => time() + (24 * 60 * 60),
    'reqUrl' => $reqData['reqUrl']
  ];

  // The $publications array is all of the data we need to render the UI.
  $publications = $cacheData['publications'];
  $publications['isFromCache'] = $isFromCache;
  $publications['isFresh'] = $isFresh;

  return [ 'cacheData' => $cacheData, 'publications' => $publications ];
}

// This is where the request for elastic search is constructed.
function build_request_data($beanObject) {
  $fisPubsEndpoint = variable_get('cu_faculty_publications_endpoint', 'https://experts.colorado.edu/es/fispubs-v1/publication/_search');
  $fisPersonEndpoint = variable_get('cu_faculty_fis_endpoint', 'https://experts.colorado.edu/es/fis/_search');
  $numberOfResultsPerPage = 25;
  $requestedNumberOfResults = 10;
  $currentPage = pager_find_page();
  $arguments = array();

  if (!empty($beanObject->field_faculty_publication_date)) {
    $date1 = strtotime($beanObject->field_faculty_publication_date[LANGUAGE_NONE][0]['value']);
    $date2 = strtotime($beanObject->field_faculty_publication_date[LANGUAGE_NONE][0]['value2']);

    $date1 = date('Y-m-d', $date1);
    $date2 = date('Y-m-d', $date2);
    $arguments['q'][] = 'publicationDate:[' . $date1 . ' TO ' . $date2 . ']';
  }

  // Check for department id or name
  if (!empty($beanObject->field_faculty_pub_department)) {
    $department = $beanObject->field_faculty_pub_department[LANGUAGE_NONE][0]['value'];

    // Search for a department id number.
    if (intval($department)) {
      $arguments['q'][] = "authors.organization.uri:*_$department";
    }

    // Use name as search term.
    // TODO: more string validation here?
    else {
      $arguments['q'][] = "authors.organization.name:$department";
    }
  }

  // Check for sort order.
  if (!empty($beanObject->field_faculty_publications_sort)) {
    $order = $beanObject->field_faculty_publications_sort[LANGUAGE_NONE][0]['value'];

    if ($order === "date-desc") {
      $arguments['sort'] = 'publicationDate:desc';
    }
    else if ($order === "date-asc") {
      $arguments['sort'] = 'publicationDate:asc';
    }
  }

  // Gather emails from all sources.
  $authorEmails = array();

  if (!empty($beanObject->field_faculty_publication_email)) {
    $authorEmails = array_merge($authorEmails, get_array_from_field_data($beanObject->field_faculty_publication_email[LANGUAGE_NONE], 'email'));
  }    

  if (!empty($beanObject->field_faculty_publication_name)) {
    $authorEmails = array_merge($authorEmails, get_array_from_field_data($beanObject->field_faculty_publication_name[LANGUAGE_NONE], 'value'));
  }

  if (!empty($beanObject->field_people_list_person_type)) {
    $tids = get_array_from_field_data($beanObject->field_people_list_person_type[LANGUAGE_NONE], 'tid');
    $authorEmails = array_merge($authorEmails, get_emails_assoc_with_jobs($tids));
  }

  $authorEmails = array_unique($authorEmails);
  $orcidResults = get_author_orcids($authorEmails, $fisPersonEndpoint);
  if (isset($orcidResults) && count($orcidResults['notFound'] > 0)) {
    $noOrcidResult = get_html_no_result_string($orcidResults['notFound'], 'publications');
    $vars['content']['no_results'][]['#markup'] = $noOrcidResult;
    if ($orcidResults['noResults']) {
      $vars['content']['no_results'][]['#markup'] = "<h4>No publications were found for any of the selected authors.</h4>";
      return;
    }
  }

  // Add all of the authors' orcids to arguments['q'] array if there are any.
  if (count($orcidResults['orcids']) > 0) {
    $orcids = $orcidResults['orcids'];
    $authorOrcidStringQuoted = formQueryStringFromArray($orcids);
    $arguments['q'][] = "authors.orcid:$authorOrcidStringQuoted";
  }

  // Check for requestedNumberOfResults.
  if (!empty($beanObject->field_faculty_pub_results)) {
    $numberOfResults = $beanObject->field_faculty_pub_results[LANGUAGE_NONE][0]['value'];
    $offset = $currentPage * $numberOfResultsPerPage;
    $arguments['from'] = $offset;
    $arguments['size'] = $numberOfResultsPerPage;

    if ($numberOfResults === 'all') {
      // 10,000 search results is the default maximum amount of Elastic Search results.
      $requestedNumberOfResults = 10000;
    }

    elseif ($numberOfResults === '25' || $numberOfResults === '50' || $numberOfResults === '100') {
      $requestedNumberOfResults = intval($numberOfResults);
    }
  }

  // Convert all 'q' arguments to a string joined by ' AND ' operator.
  if (count($arguments['q']) > 1) {
    $arguments['q'] = implode(' AND ', $arguments['q']);
  }
  elseif (count($arguments['q']) === 1) {
    $arguments['q'] = $arguments['q'][0];
  }

  // Form the final request url.
  $elasticSearchRequest = url($fisPubsEndpoint, ['query' => $arguments]);
  return [ 'reqUrl' => $elasticSearchRequest, 'requestedNumberOfResults' => $requestedNumberOfResults ];
}

function cu_faculty_publications_bundle_person_names() {
  $query = db_select('field_data_field_person_email', 'email');
  $query->join('field_data_field_person_first_name', 'fn', 'email.entity_id = fn.entity_id');
  $query->join('field_data_field_person_last_name', 'ln', 'email.entity_id = ln.entity_id');
  $query->addField('email', 'field_person_email_email', 'e_mail');
  $query->addField('fn', 'field_person_first_name_value', 'first_name');
  $query->addField('ln', 'field_person_last_name_value', 'last_name');
  $query->orderBy('last_name', 'ASC');
  $result = $query->execute();
  
  $facultyNamesAndEmails = [];
  foreach ($result as $record) {
    $firstName = $record->first_name;
    $lastName = $record->last_name;
    $email = strtolower($record->e_mail);
    $facultyNamesAndEmails[$email] = "$firstName $lastName";
  }

  return $facultyNamesAndEmails;
}

function get_emails_assoc_with_jobs($jobsTidArray) {
  $query = db_select('field_data_field_person_email', 'email');
  $query->join('field_data_field_person_job_type', 'job', 'job.entity_id = email.entity_id');
  $query->addField('email', 'field_person_email_email');
  $query->condition('job.field_person_job_type_tid', $jobsTidArray, 'IN');

  $result = $query->execute()->fetchCol();
  $emails = array_map(function($email) {return strtolower($email);}, $result);
  return $emails;
}

function cu_faculty_publications_sort() {
  return array('date-desc' => 'Newest to Oldest', 'date-asc' => 'Oldest to Newest');
}

function cu_faculty_publications_results() {
  return array('25' => '25', '50' => '50' , '100' => '100', 'all' => 'ALL');
}
// End cu_faculty_publications_bundle_preprocess_entity() helper functions.

/**
  * Implements hook_secure_permissions().
  *
  * Adding permissions for newsletter
  */
function cu_faculty_publications_bundle_secure_permissions($role) {
  $permissions = array(
    'anonymous user' => array(
      'view any faculty_publications bean',
    ),
    'authenticated user' => array(
      'view any faculty_publications bean',
    ),
    'administrator' => array(
      'create any faculty_publications bean',
      'delete any faculty_publications bean',
      'edit any faculty_publications bean',
      'view any faculty_publications bean',
    ),
    'developer' => array(
      'create any faculty_publications bean',
      'delete any faculty_publications bean',
      'edit any faculty_publications bean',
      'view any faculty_publications bean',
    ),
    'edit_my_content' => array(
      'view any faculty_publications bean',
    ),
    'edit_only' => array(
      'edit any faculty_publications bean',
      'view any faculty_publications bean',
    ),
    'site_editor' => array(
      'create any faculty_publications bean',
      'delete any faculty_publications bean',
      'edit any faculty_publications bean',
      'view any faculty_publications bean',
    ),
    'site_owner' => array(
      'create any faculty_publications bean',
      'delete any faculty_publications bean',
      'edit any faculty_publications bean',
      'view any faculty_publications bean',
    ),
  );

  if (isset($permissions[$role])) {
    return $permissions[$role];
  }
}

/**
  * Implements hook_flush_caches().
  */
function cu_faculty_publications_bundle_flush_caches() {
  return array('cache_cu_faculty_publications_bundle');
}